---
title: "字节跳动 Java 面试题汇总"
tags:
  - Java
  - ByteDance
  - Interview Questions
---

## 字节跳动（北京）系统部门后端开发

### 一面 40mins

* 自我介绍
* Redis的基本数据类型、跳表是怎样的数据结构。
* 快速排序的原理。
* 数据库事务：ACID。
    * 持久性：redo log
    * MVVC：undo log
* bin log和redo log是做什么的？
* 说说数据库索引的原理（提到B+树、B树、哈希索引的区别）
* 操作系统收到包后如何将包打到80端口？
* 进程是如何切换的？（保存、读取上下文，虚拟地址。。。）
* Leetcode 189 旋转数组

### 二面 50mins

* HashMap原理（底层数据结构、put的过程、扩容、rehash过程）
* ConcurrentHashMap 相关问题（JDK7与JDK8的区别、各自是如何保证线程安全）
* 多线程coding：两个线程交替打印`1~10`
* 用数组实现队列
* SQL：统计平均分大于80分的学生中，A课程分数超过90分的学生数量
* 算法题省略。。。

### 三面 40mins

* Java中常用的容器有哪些？他们的联系是什么？
* 如果我要拿一个自定义的Object来做HashMap的key，我至少需要重写什么方法？

hashcode()和equals()

* 上道题追问：为什么两个都要重写？只重写其中一个会怎么样？

涉及到HashMap的原理，分别分析hashcode()和equals()的结果一个相等一个不相等的影响。

* Redis为什么用单线程？为什么单线程还可以处理大量的请求？

答：瓶颈不在CPU、I/O多路复用模型。

* 如何在两个非常大的日志文件中查找相同行，并打印到第三个文件中。

答：文件非常大所以不可能一次性装入内存，可以用哈希算法将大的日志文件分成若干个小文件，然后在小文件中进行比较。

* 上道题追问：如果哈希分布的结果不均匀怎么办？

* 说说集中I/O模型的区别。（BIO、AIO、NIO）

* 服务器收到一个业务请求，从数据库获取数据，再返回给前端，一共有多少次I/O？

* Leetcode 121 买卖股票的最佳时机

## 字节飞书Java四轮面经

### 一面 52mins

* OAuth2.0 整个流程？

* 秒杀系统超卖问题（redisson分布式信号量，商品库库存进redis扣减）

* redisson 分布式信号量底层实现

* MySQL索引为什么能加快查询速度，联合索引在B+树中怎么存？

MySQL索引使用B+树数据结构，主键索引存放了整行数据，所以不需要回表查询。联合索引是非聚簇索引，非聚簇索引的叶子节点存放了索引字段以及主键索引的指针，查询时取到主键回表到聚簇索引用主键查询该主键对应的行数据。

* Redis基本数据类型，如何使用

* Redis中的key的淘汰策略？

惰性删除：访问key时如果过期了就删除，对CPU友好，内存不友好。

定期删除：遍历字典删除过期的key。COU不友好。

定时删除：在设置key的过期时间的同时，创建一个定时器，让定时器在key的过期时间到来时，立即执行对key的删除；对CPU最不友好

* 算法题：未排序数组，在O(n)时间内找出最长数字连续序列的长度。

### 二面 80mins

* 编程：大数加法

* synchronized放在静态方法和非静态方法有什么区别？

* `synchronized(null)`会发生什么？这个线程拿到锁还是没有拿到锁？(会修改对象的markword，null没有markword，所以会报空指针)

* synchronized锁升级过程？

* synchronized(Integer)会发生什么问题？例如：syncronized(1)。

Integer在[-128, 127]有缓存对象，也就是说如果两个线程都执行到了`synchronized(1)`，这两个线程会抢同一把锁，例如：线程1执行 method1()，线程2执行 method2()，两个方法中都有synchronized(1)，那么这就会导致线程1执行时线程2没法执行。

* 线程池有 `coreSize` 和 `maxSize`，如果 `codeSize = 50, maxSize = 30`，会创建几个线程？

* 如果 `codeSize = 50, maxSize = 50`，会创建几个线程？

会创建50个线程，如果阻塞队列慢了会直接触发拒绝策略。

* ReentrantLock默认是公平还是非公平？

默认非公平，性能好。

* 公平锁怎么实现的？

AQS有个队列，队首是当前Runnable状态的线程，后面的都是Waiting状态的线程，公平锁是在cas修改state之前判断队列是否有Waiting状态的线程，如果有就将当前线程加到队尾。

* 