---
title: "并查集"
---

这篇文章主要讲讲 **Union Find[^1]** 算法， 也就是我们常说的**并查集**算法。主要用于图算法中的==动态连通性==。

## 动态连通性

!!! note
    
    假设输入一连串的整数对，其中一对整数对`p`和`q`，它们分别代表不同类型的对象，这对整数对`p`和`q`是相连的。则这两个对象可以属于同一个连通分量，而再接收之后的整数对时，则可以判断整数对中的两个元素是否属于同一个连通分量，来过滤掉无意义的整数对，因为如果整数对中的两个元素在同一个连通分量中，则可以肯定的是它们一定是相连通的。

简单来说，这个动态连通性，可以想象成一个图结构，图中的节点有些互相连接，有些不互相连接，如果两个元素相连，则它们具有以下特性：

* Symmetric (对称性): 如果`p`与`q`连接，则`q`与`p`也相连
* Transitive (传递性): 如果`p`与`q`相连，`q`与`r`相连，则`p`与`r`也相连
* Reflexive (自反性): 自身与自身相连

而动态连通性的目标就是要找出无意义的**pair**，例如一个整数对`p`与`q`，如果之前的整数对已经表明他们是相连接的了，那我们就忽略这个整数对，继续处理下一个整数对。

而**Union Find**主要有以下几个实现：

``` title="Union Find Pseudo Code"
public class UF {
    UF(int n); // 初始化n个连接点(0 ~ n-1)
    void union(int p, int q); // 添加p与q的连接
    int find(int p); // 找到p的连通分量
    boolean connected(int p, int q); // 判断p与q是否连通
    int count(); //返回图中有多少个连通分量
}
```

## 实现


[^1]: [Princeton University - Union Find](https://algs4.cs.princeton.edu/15uf/)